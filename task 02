//code--->

#include <iostream>
#include <fstream>
#include <vector>
#include <thread>
#include <zlib.h>  // for compression (zlib library required)

using namespace std;

// Function to compress a chunk of data
void compressChunk(const vector<char>& input, vector<char>& output, int id) {
    uLong srcLen = input.size();
    uLong destLen = compressBound(srcLen);
    output.resize(destLen);

    if (compress(reinterpret_cast<Bytef*>(&output[0]), &destLen,
                 reinterpret_cast<const Bytef*>(&input[0]), srcLen) != Z_OK) {
        cerr << "Compression failed in thread " << id << endl;
    }
    output.resize(destLen);
}

// Function to decompress a chunk of data
void decompressChunk(const vector<char>& input, vector<char>& output, int id, uLong originalSize) {
    output.resize(originalSize);
    if (uncompress(reinterpret_cast<Bytef*>(&output[0]), &originalSize,
                   reinterpret_cast<const Bytef*>(&input[0]), input.size()) != Z_OK) {
        cerr << "Decompression failed in thread " << id << endl;
    }
    output.resize(originalSize);
}

int main() {
    string inputFile = "input.txt";
    string compressedFile = "compressed.bin";
    string decompressedFile = "output.txt";

    // Step 1: Read file
    ifstream in(inputFile, ios::binary);
    vector<char> inputData((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();

    cout << "Original size: " << inputData.size() << " bytes" << endl;

    // Split data into 2 chunks (multithreading demo)
    size_t half = inputData.size() / 2;
    vector<char> part1(inputData.begin(), inputData.begin() + half);
    vector<char> part2(inputData.begin() + half, inputData.end());

    vector<char> comp1, comp2;

    // Step 2: Compress in parallel
    thread t1(compressChunk, cref(part1), ref(comp1), 1);
    thread t2(compressChunk, cref(part2), ref(comp2), 2);
    t1.join();
    t2.join();

    // Save compressed data
    ofstream out(compressedFile, ios::binary);
    size_t size1 = comp1.size(), size2 = comp2.size();
    out.write(reinterpret_cast<char*>(&size1), sizeof(size1));
    out.write(&comp1[0], size1);
    out.write(reinterpret_cast<char*>(&size2), sizeof(size2));
    out.write(&comp2[0], size2);
    out.close();

    cout << "Compressed size: " << size1 + size2 << " bytes" << endl;

    // Step 3: Decompress
    ifstream inComp(compressedFile, ios::binary);
    inComp.read(reinterpret_cast<char*>(&size1), sizeof(size1));
    comp1.resize(size1);
    inComp.read(&comp1[0], size1);
    inComp.read(reinterpret_cast<char*>(&size2), sizeof(size2));
    comp2.resize(size2);
    inComp.read(&comp2[0], size2);
    inComp.close();

    vector<char> decomp1, decomp2;
    thread t3(decompressChunk, cref(comp1), ref(decomp1), 1, part1.size());
    thread t4(decompressChunk, cref(comp2), ref(decomp2), 2, part2.size());
    t3.join();
    t4.join();

    // Save final output
    ofstream outFinal(decompressedFile, ios::binary);
    outFinal.write(&decomp1[0], decomp1.size());
    outFinal.write(&decomp2[0], decomp2.size());
    outFinal.close();

    cout << "Decompressed size: " << decomp1.size() + decomp2.size() << " bytes" << endl;
    cout << "âœ… Compression & Decompression complete!" << endl;

    return 0;
}


CMakeslist.txt-->

cmake_minimum_required(VERSION 3.10)
project(task2)

set(CMAKE_CXX_STANDARD 17)

find_package(ZLIB REQUIRED)

add_executable(task2 task2.cpp)
target_link_libraries(task2 ZLIB::ZLIB)


input.txt--->

hello, this is mohan kumar from patna (bihar).
i am persuing my b.tech from tula's institute dehradun.
